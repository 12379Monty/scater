## Wrappers for kallisto quantification of abundance of RNA-seq reads

################################################################################
#' Run kallisto on FASTQ files to quantify feature abundance
#' 
#' Run the abundance quantification tool \code{kallisto} on a set of FASTQ 
#' files. Requires \code{kallisto} (\url{http://pachterlab.github.io/kallisto/})
#' to be installed and a kallisto feature index must have been generated prior 
#' to using this function. See the kallisto website for installation and basic
#' usage instructions.
#' 
#' @param targets_file character string giving the path to a tab-delimited text 
#' file with either 2 columns (single-end reads) or 3 columns (paired-end reads)
#' that gives the sample names (first column) and FastQ file names (column 2 and
#' if applicable 3). The file is assumed to have column headers, although these 
#' are not used.
#' @param transcript_index character string giving the path to the kallisto 
#' index to be used for the feature abundance quantification.
#' @param single_end logical, are single-end reads used, or paired-end reads?
#' @param output_prefix character string giving the prefix for the output folder
#' that will contain the kallisto results. The default is \code{"output"} and 
#' the sample name (column 1 of \code{targets_file}) is appended (preceded by an
#' underscore).
#' @param fragment_length scalar integer or numeric giving the estimated 
#' average fragment length. Required argument if \code{single_end} is \code{TRUE}, 
#' optional if \code{FALSE} (kallisto default for paired-end data is that the 
#' value is estimated from the input data.
#' @param n_cores integer giving the number of cores (nodes/threads) to use for
#' the kallisto jobs. The package \code{parallel} is used. Default is 2 cores.
#' @param n_bootstrap_samples integer giving the number of bootstrap samples 
#' that kallisto should use (default is 0). With bootstrap samples, uncertainty 
#' in abundance can be quantified.
#' @param bootstrap_seed scalar integer or numeric giving the seed to use for 
#' the bootstrap sampling (default used by kallisto is 42). Optional argument.
#' @param plaintext logical, if \code{TRUE} then bootstrapping results are 
#' returned in a plain text file rather than an HDF5 
#' \url{https://www.hdfgroup.org/HDF5/} file.
#' @param verbose logical, should timings for the run be printed?
#' 
#' @details A kallisto transcript index can be built from a FASTA file: 
#' \code{kallisto index [arguments] FASTA-file}. See the kallisto documentation
#' for further details.
#' 
#' @return A list containing three elements for each sample for which feature 
#' abundance has been quantified: (1) \code{kallisto_call}, the call used for 
#' kallisto, (2) \code{kallisto_log} the log generated by kallisto, and (3) 
#' \code{output_dir} the directory in which the kallisto results can be found.
#' 
#' @export
#' @examples
#' \dontrun{
#' ## If in kallisto's 'test' directory, then try these calls:
#' ## Generate 'targets.txt' file:
#' write.table(data.frame(Sample="sample1", File1="reads_1.fastq.gz", File2="reads_1.fastq.gz"), 
#'  file="targets.txt", quote=FALSE, row.names=FALSE, sep="\t")
#' kallisto_log <- runKallisto("targets.txt", "transcripts.idx", single_end=FALSE, 
#'          output_prefix="output", verbose=TRUE, n_bootstrap_samples=10)
#' }
runKallisto <- function(targets_file, transcript_index, single_end=TRUE,
                        output_prefix="output", fragment_length=NULL, n_cores=2, 
                        n_bootstrap_samples=0, bootstrap_seed=NULL,
                        plaintext=FALSE, verbose=TRUE) {
    targets <- read.delim(targets_file, stringsAsFactors=FALSE, header=TRUE)
    if( !(ncol(targets)==2 | ncol(targets)==3) )
        stop("Targets file must have either 2 columns (single-end reads) or 
             3 columns (paired-end reads). File should be tab-delimited with
             column headers")
    samples <- targets[,1]
    ## If we have single-end reads then fragment_length must be defined
    if( single_end & is.null(fragment_length) )
        stop("If single-end reads are used, then fragment_length must be 
             defined. Either a scalar giving the average fragment length to use
             for all samples, or a vector providing the ave fragment length for
             each sample.")
    else
        paired_end <- !single_end
    ## Generate calls to kallisto
    output_dirs <- paste(output_prefix, samples, sep="_")
    kallisto_args <- paste("quant -i", transcript_index, "-o",
                            output_dirs, "-b", n_bootstrap_samples)
    names(kallisto_args) <- samples
    if( !is.null(fragment_length) )
        kallisto_args <- paste(kallisto_args, "-l", fragment_length)
    if( !is.null(bootstrap_seed) )
        kallisto_args <- paste0(kallisto_args, " --seed=", bootstrap_seed)
    if( plaintext ) # output bootstrap results in a plaintext file
        kallisto_args <- paste0(kallisto_args, " --plaintext" )
    kallisto_args <- paste(kallisto_args, targets[,2])
    if(paired_end)
        kallisto_args <- paste(kallisto_args, targets[,3])
    ##     
    if(verbose)
        print(paste("Analysis started: ", Sys.time()))
    cl <- parallel::makeCluster(n_cores)
    # one or more parLapply calls to kallisto
    kallisto_log <- parallel::parLapply(cl, kallisto_args, .call_kallisto, 
                                        output_prefix, verbose)
    #     parallel::parLapply(cl, kallisto_args,
    #               function(kcall) {system(kcall, ignore.stdout=!verbose, 
    #                                      ignore.stderr=!verbose))
    parallel::stopCluster(cl)
    ## Return log of kallisto jobs, so user knows where to find results
    names(kallisto_log) <- samples
    if(verbose) {
        print(paste("Analysis completed: ", Sys.time()))
        print(paste("Processed", length(samples), "samples"))    
    }
    for(i in seq_len(length(kallisto_log))) {
        kallisto_log[[i]]$output_dir <- output_dirs[i]
    }
    kallisto_log
}

.call_kallisto <- function(kcall, output_prefix, verbose=TRUE) {
    out <- tryCatch(ex <- system2("kallisto", kcall, stdout=TRUE, stderr=TRUE), 
                    warning=function(w){w}, error=function(e){e})
    list(kallisto_call=paste("kallisto", kcall), kallisto_log=out)
}



################################################################################
#' Read kallisto results for a single sample into a list
#' 
#' @param directory character string giving the path to the directory containing
#' the kallisto results for the sample.
#' @param read_h5 logical, if \code{TRUE} then read in bootstrap results from 
#' the HDF5 object produced by kallisto.
#' 
#' @details The directory is expected to contain results for just a single 
#' sample. Putting more than one sample's results in the directory will result
#' in unpredictable behaviour with this function. The function looks for the 
#' files (with the default names given by kallisto) 'abundance.txt', 
#' 'run_info.json' and (if \code{read_h5=TRUE}) 'abundance/h5'. If these files 
#' are missing, or if results files have different names, then this function 
#' will not find them. 
#' 
#' @return A list with two elements: (1) a data.frame \code{abundance} with 
#' columns for 'target_id' (feature, transcript, gene etc), 'length' (feature 
#' length), 'eff_length' (effective feature length), 'est_counts' (estimated 
#' feature counts), 'tpm' (transcripts per million) and possibly many columns 
#' containing bootstrap estimated counts; and (2) a list \code{run_info} with
#' details about the kallisto run that generated the results.
#' 
#' @export
#' @examples
#' # If kallisto results are in the directory "output", then call:
#' # readKallistoResultsOneSample("output")
readKallistoResultsOneSample <- function(directory, read_h5=FALSE) {
    ## Read in abundance information for the sample
    abundance <- readr::read_tsv(paste0(directory, "/abundance.txt"),
                                 col_types="ciddd")
    ## Read in run information
    run_info <- rjson::fromJSON(file=paste0(directory, "/run_info.json"))
    ## Read in HDF5 data file with bootstrap results
    if( read_h5 ) {
        h5 <- rhdf5::h5read(paste0(directory, "/abundance.h5"), "/")
        rhdf5::H5close()
        if( h5$aux$num_bootstrap > 0 ) {
            boot_mat <- data.frame(matrix(unlist(h5$bootstrap), 
                                          nrow=length(h5$est_counts), 
                                          ncol=h5$aux$num_bootstrap))
            colnames(boot_mat) <- names(h5$bootstrap)
            abundance <- cbind(abundance, boot_mat)
        }        
    }
    list(abundance=abundance, run_info=run_info)
}

#' Read kallisto results from a batch of jobs 
#' 
#' After generating transcript/feature abundance results using kallisto for a 
#' batch of samples, read these abundance values into an \code{SCESet} object.
#' 
#' @param kallisto_log list, generated by \code{runKallisto}. If provided, then 
#' \code{samples} and \code{directories} arguments are ignored.
#' @param samples character vector providing a set of sample names to use for 
#' the abundance results.
#' @param directories character vector providing a set of directories containing
#' kallisto abundance results to be read in.
#' @param read_h5 logical, should the bootstrap results be read in from the HDF5
#' objects produced by kallisto?
#' @param verbose logical, should function provide output about progress?
#' 
#' @details This function expects to find only one set of kallisto abundance 
#' results per directory; multiple adundance results in a given directory will 
#' be problematic.
#' 
#' @export
#' @examples
#' \dontrun{
#' kallisto_log <- runKallisto("targets.txt", "transcripts.idx", single_end=FALSE, 
#'          output_prefix="output", verbose=TRUE, n_bootstrap_samples=10)
#' sceset <- readKallistoResults(kallisto_log)
#' }
#' 
readKallistoResults <- function(kallisto_log=NULL, samples=NULL, 
                                directories=NULL, read_h5=FALSE, verbose=TRUE) {
    ## Checks on arguments
    if( !is.null(kallisto_log) ) {
        cat("Using kallisto_log to define samples and results directories.")
        if( !is.list(kallisto_log) )
            stop("The kallisto_log should be a list returned by runKallisto()")
        samples <- names(kallisto_log)       
        directories <- sapply(kallisto_log, function(x) {x$output_dir})
    } else {
        if( is.null(samples) | is.null(directories) )
            stop("If kallisto_log argument is not used, then both samples and directories must be provided.")
        if( length(samples) != length(directories) )
            stop("samples and directories arguments must be the same length")
    }
    
    ## Read first file to get size of feature set
    s1 <- readKallistoResultsOneSample(directories[1], read_h5=read_h5)
    nsamples <- length(samples)
    nfeatures <- nrow(s1$abundance)
    nbootstraps <- s1$run_info$n_bootstraps
    navec_samples <- rep(NA, nsamples)
    
    ## Set up results objects
    pdata <- data.frame(n_targets=navec_samples, n_bootstraps=navec_samples,
                        kallisto_version=navec_samples, 
                        index_version=navec_samples, start_time=navec_samples,
                        call=navec_samples)
    rownames(pdata) <- samples
    fdata <- data.frame(feature_id=s1$abundance$target_id, 
                        feature_length=s1$abundance$length, 
                        feature_eff_length=s1$abundance$eff_length)
    rownames(fdata) <- s1$abundance$target_id
    est_counts <- tpm <- matrix(NA, nrow=nfeatures, ncol=nsamples)
    colnames(est_counts) <- colnames(tpm) <- samples
    rownames(est_counts) <- rownames(tpm) <- s1$abundance$target_id
    if( read_h5 ) {
        bootstraps <- array(NA, dim=c(nfeatures, nsamples, nbootstraps))
        rownames(bootstraps) <- s1$abundance$target_id
        colnames(bootstraps) <- samples
    }
    
    ## Read kallisto results into results objects
    if( verbose )
        cat(paste("\nReading results for", nsamples, "samples: "))
    for( i in seq_len(nsamples) ) {
        tmp_samp <- readKallistoResultsOneSample(directories[i], read_h5=read_h5)
        ## counts
        est_counts[,i] <- tmp_samp$abundance$est_counts
        ## tpm
        tpm[,i] <- tmp_samp$abundance$tpm
        ## run info
        pdata$n_targets[i] <- tmp_samp$run_info$n_targets
        pdata$n_bootstraps[i] <- tmp_samp$run_info$n_bootstraps
        pdata$kallisto_version[i] <- tmp_samp$run_info$kallisto_version
        pdata$index_version[i] <- tmp_samp$run_info$index_version
        pdata$start_time[i] <- tmp_samp$run_info$start_time
        pdata$call[i] <- tmp_samp$run_info$call
        ## bootstraps
        if( read_h5 )
            bootstraps[,i,] <- as.matrix(tmp_samp$abundance[,-c(1:5)])
        if( verbose )
            cat(".")
    }
    if( verbose )
        cat("\n")
    ## Produce SCESet object
    pdata <- new("AnnotatedDataFrame", pdata)
    fdata <- new("AnnotatedDataFrame", fdata)
    sce_out <- newSCESet(cellData=NULL, phenoData=pdata, featureData=fdata,
                         countData=est_counts, lowerDetectionLimit=0)
    tpm(sce_out) <- tpm
    if( read_h5 )
        bootstraps(sce_out) <- bootstraps
    ## Return SCESet object
    sce_out
}



#' Get feature annotation information from Biomart
#' 
#' Use the \code{biomaRt} package to add feature annotation information to an 
#' \code{SCESet}. 
#' 
#' @param object an \code{SCESet} object
#' @param filters character vector defining the "filters" terms to pass to the
#' biomaRt::getBM function.
#' @param attributes
#' 
#' @details See the documentation for the biomaRt package, specifically for the
#' functions \code{useMart} and \code{getBM}, for information on what are 
#' permitted values for the filters, attributes, biomart, dataset and host 
#' arguments.
#' 
#' 
#' 
getBMFeatureAnnos <- function(object, filters="ensembl_transcript_id", 
                              attributes=c("ensembl_transcript_id", 
                                           "ensembl_gene_id", "mgi_symbol", 
                                           "chromosome_name", "transcript_biotype"
                                           "transcript_start", "transcript_end", 
                                           "transcript_count"), 
                              gene_symbol="mgi_symbol",
                              gene_id="ensembl_gene_id",
                              biomart="ensembl", 
                              dataset="mmusculus_gene_ensembl",
                              host=NULL) {
    ## Define Biomart Mart to use
    if( is.null(host) )
        bmart <- biomaRt::useMart(biomart=biomart, dataset=biomart)
    else 
        bmart <- biomaRt::useMart(biomart=biomart, dataset=dataset, host=host) 
    ## Define feature IDs from SCESet object
    feature_ids <- featureNames(sce_kall_mmus)
    ## Get annotations from biomaRt
    feature_info <- biomaRt::getBM(attributes=attributes, 
                                   filters=filters, 
                                   values=feature_ids, mart=bmart)
    ## Match the feature ids to the filters ids used to get info from biomaRt
    mm <- match(feature_ids, feature_info[[filters]])
    feature_info_full <- feature_info[mm, ]
    rownames(feature_info_full) <- feature_ids
    ## Define gene symbol and gene id
    feature_info_full$gene_symbol <- feature_info_full[[gene_symbol]]
    feature_info_full$gene_id <- feature_info_full[[gene_id]]
    ## Use rownames for gene symbol if gene symbol is missing
    na_symbol <- (is.na(feature_info_full$gene_symbol) | feature_info_full$gene_symbol == "")
    feature_info_full$gene_symbol[na_symbol] <- 
        rownames(feature_info_full)[na_symbol]
    ## Use rownames from SCESet object (feature IDs) for gene_id if na
    feature_info_full$gene_id[is.na(feature_info_full$gene_id)] <-
        rownames(feature_info_full)[is.na(feature_info_full$gene_id)]
    ## Add new feature annotations to SCESet object
    fData(object) <- cbind(fData(object), feature_info_full)
    ## Return SCESet object
    object
}

#' Summarise feature counts
#' 
#' Create a new \code{SCESet} with counts summarised at a different feature 
#' level. A typical use would be to summarise transcript-level counts at gene
#' level.
#' 


# Summarise counts at the gene level
tmp_counts <- dplyr::tbl_df(data.frame(ensembl_gene_id=fData(sce_kall_mmus)$ensembl_gene_id, 
                         counts(sce_kall_mmus)))
tmp_counts[1:10, 1:6]
tmp_counts_long <- reshape2::melt(tmp_counts)
tmp_counts_long %>% head
tmp_counts_long <- dplyr::group_by(tmp_counts_long, ensembl_gene_id, variable)
counts_gene_long <- dplyr::summarise(tmp_counts_long, est_counts=sum())
counts_gene_long %>% head
counts_gene <- reshape2::acast(tmp_counts_long, ensembl_gene_id ~ variable, sum)
dim(counts_gene)
sum(counts_gene != 0)
sum(counts_gene == 0)
all(counts_gene == 0)
counts_gene[sample(nrow(counts_gene), 10), 1:6]
counts_gene[,1:6] %>% tail


## Use gene symbols for rownames
sum(duplicated(fData(sce_kall_mmus)$mgi_symbol))
rownames(sce_kall_mmus) <- paste(fData(sce_kall_mmus)$hgnc_symbol, 
                             fData(sce_kall_mmus)$ensembl_gene_id, sep="_")
rownames(sce_kall_mmus) %>% head
fData(sce_kall_mmus) %>% tail(20)


# # Compare these counts to those produced by WTCHG Core
# load("~/021_Cell_Cycle/cache/scs_mouse_unfiltered_vers2.RData")
# scs_mouse
# head(featureNames(scs_mouse))
# ## Keep overlapping genes for kallisto data
# sum(colnames(counts_gene) %in% scs_mouse$Readgroup)
# keep_col <- colnames(counts_gene) %in% scs_mouse$Readgroup
# keep_row <- rownames(counts_gene) %in% featureNames(scs_mouse)
# counts_kallisto <- counts_gene[keep_row, keep_col]
# dim(counts_kallisto)
# ## Keep overlapping genes for Core data
# keep_row <- featureNames(scs_mouse) %in% rownames(counts_kallisto)
# keep_col <- scs_mouse$Readgroup %in% colnames(counts_kallisto)
# scs_mouse_compare <- scs_mouse[keep_row, keep_col]
# dim(scs_mouse_compare)
# ## Get genes and cells ordered the same way
# mcol <- match(scs_mouse_compare$Readgroup, colnames(counts_kallisto))
# identical(colnames(counts_kallisto)[mcol], scs_mouse_compare$Readgroup)
# mrow <- match(featureNames(scs_mouse_compare), rownames(counts_kallisto))
# identical(rownames(counts_kallisto)[mrow], featureNames(scs_mouse_compare))
# counts_kallisto <- counts_kallisto[mrow, mcol]
# ## Plot log-counts to compare quantification
# par(mfcol=c(2,2))
# for(i in 1:4) {
#     rsamp <- sample(nrow(counts_kallisto), 1000)
#     csamp <- sample(ncol(counts_kallisto), 30)
#     plot(x=(counts(scs_mouse_compare)[rsamp, csamp] + 0.5), 
#          y=(counts_kallisto[rsamp, csamp] + 0.5),
#          pch=21, bg=scales::alpha("gray30", 0.1), col="gray50", cex=0.7,
#          panel.first=grid(), log="xy", asp=1, xlab="Counts (+0.5) from WTCHG Core",
#          ylab="Counts (+0.5) from kallisto")
#     title("Sample from 1000 genes, 30 cells")
#     abline(0,1)
# }
# 
# 
